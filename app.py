from flask import Flask, request, jsonify
from flask_cors import CORS
import joblib
import numpy as np
import rasterio
import requests
import os
from glob import glob
from pyproj import Transformer
from datetime import datetime, timedelta

app = Flask(__name__)
CORS(app)

# 1. Load the New Smart AI Model (Generated by train_flood_ai.py)
try:
    model = joblib.load('flood_model.pkl')
    print("✅ AI Brain Loaded")
except:
    print("⚠️ Model not found (Run train_flood_ai.py first)")

# 2. Load LiDAR Tiles & Calculate Blue Box Coverage
TILE_FOLDER = "tiles"
print(f"⏳ Scanning {TILE_FOLDER} for LiDAR tiles...")

tile_datasets = []
tif_files = glob(os.path.join(TILE_FOLDER, "*.tif"))
coverage_bounds = [] 

if not tif_files:
    print("❌ NO TILES FOUND!")
else:
    for tif_path in tif_files:
        try:
            ds = rasterio.open(tif_path)
            tile_datasets.append(ds)
            
            # --- PRESERVE BLUE BOX LOGIC ---
            # Calculate Lat/Lon bounds for this tile to send to frontend
            left, bottom, right, top = ds.bounds
            dst_crs = 'EPSG:4326'
            if ds.crs != dst_crs:
                t = Transformer.from_crs(ds.crs, dst_crs, always_xy=True)
                min_lon, min_lat = t.transform(left, bottom)
                max_lon, max_lat = t.transform(right, top)
                coverage_bounds.append({
                    "coords": [[min_lon, max_lat], [max_lon, max_lat], [max_lon, min_lat], [min_lon, min_lat], [min_lon, max_lat]],
                    "name": os.path.basename(tif_path)
                })
        except: pass
    print(f"✅ SYSTEM READY: {len(tile_datasets)} Tiles Active.")

# Transformer (GPS -> UTM Zone 44N)
transformer = Transformer.from_crs("EPSG:4326", "EPSG:32644", always_xy=True)

# 3. REAL WEATHER FUNCTION (Preserved)
def get_real_weather():
    try:
        # Open-Meteo API for Haridwar coordinates
        url = "https://api.open-meteo.com/v1/forecast?latitude=29.956&longitude=78.18&current=rain,showers"
        response = requests.get(url)
        data = response.json()
        current_rain = data['current']['rain'] + data['current']['showers']
        return current_rain
    except:
        return 0.0 # Fallback

# 4. ELEVATION CHECKER (Preserved)
def get_elevation_from_mosaic(lat, lon):
    if not tile_datasets:
        return None, "No Tiles Loaded"
    
    utmx, utmy = transformer.transform(lon, lat)

    for ds in tile_datasets:
        try:
            if (ds.bounds.left <= utmx <= ds.bounds.right) and \
               (ds.bounds.bottom <= utmy <= ds.bounds.top):
                row, col = ds.index(utmx, utmy)
                elevation = ds.read(1)[row, col]
                if -100 < elevation < 9000:
                    return float(elevation), os.path.basename(ds.name)
        except:
            continue
            
    return None, "Outside Coverage"

# --- ROUTES ---

@app.route('/tiles-coverage', methods=['GET'])
def tiles_coverage():
    # Sends the exact shapes of your tiles to the map (Blue Boxes)
    return jsonify(coverage_bounds)


@app.route('/predict-live', methods=['GET'])
def predict_live():
    # 1. Check for Simulation Override
    sim_rain = request.args.get('sim_rain')
    
    # Initialize default weather values
    weather_data = {
        'temp': 25.0,
        'humidity': 60,
        'wind': 5.0,
        'rain': 0.0
    }
    
    try:
        if sim_rain:
            # SIMULATION MODE: Use manual rain, but fetch real temp/wind for realism
            real_rain = float(sim_rain)
            source_text = "⚠️ SIMULATION MODE"
            # Still try to fetch real ambient weather (optional, or just use defaults)
        else:
            # LIVE MODE: Fetch everything from Open-Meteo
            url = "https://api.open-meteo.com/v1/forecast?latitude=29.956&longitude=78.18&current=temperature_2m,relative_humidity_2m,wind_speed_10m,rain,showers"
            response = requests.get(url)
            data = response.json()
            
            weather_data['temp'] = data['current']['temperature_2m']
            weather_data['humidity'] = data['current']['relative_humidity_2m']
            weather_data['wind'] = data['current']['wind_speed_10m']
            # Total rain = rain + showers
            weather_data['rain'] = data['current']['rain'] + data['current']['showers']
            
            real_rain = weather_data['rain']
            source_text = "Open-Meteo Live API"

    except Exception as e:
        print(f"Weather API Error: {e}")
        real_rain = 0.0
        source_text = "Offline / Error"

    # 3. Predict Risk using AI
    est_discharge = 5000 + (real_rain * 1500) 
    
    try:
        features = np.array([[real_rain, est_discharge]])
        risk_prediction = model.predict(features)[0] 
    except:
        risk_prediction = 0
        if est_discharge > 30000: risk_prediction = 1
        if est_discharge > 80000: risk_prediction = 2
    
    return jsonify({
        'rainfall': real_rain,
        'temperature': weather_data['temp'],
        'humidity': weather_data['humidity'],
        'wind_speed': weather_data['wind'],
        'discharge': round(est_discharge, 0),
        'risk_level': int(risk_prediction),
        'source': source_text
    })


# ... (Keep existing imports) ...

@app.route('/get-forecast', methods=['GET'])
def get_forecast():
    try:
        # Check if we are in Simulation Mode
        sim_rain = request.args.get('sim_rain')
        
        forecast_data = []
        now = datetime.now()

        if sim_rain:
            # --- SIMULATION LOGIC ---
            # If user simulates 200mm, we create a fake 12-hour "Flood Scenario"
            base_rain = float(sim_rain)
            
            for i in range(12):
                future_time = now + timedelta(hours=i)
                
                # Create a "Curve": Rain stays high for 3 hours, then slowly decreases
                if i < 3:
                    hourly_rain = base_rain + np.random.normal(0, 5) # Sustained peak
                else:
                    hourly_rain = base_rain * (0.9 ** (i-2)) # Decay curve
                
                # Calculate Discharge based on this fake rain
                est_discharge = 5000 + (hourly_rain * 1500)
                
                forecast_data.append({
                    "time": future_time.strftime("%H:%M"),
                    "rain": round(hourly_rain, 1),
                    "discharge": round(est_discharge, 0),
                    "risk": 2 if est_discharge > 80000 else (1 if est_discharge > 30000 else 0)
                })
                
        else:
            # --- REAL LIVE LOGIC (Open-Meteo) ---
            url = "https://api.open-meteo.com/v1/forecast?latitude=29.956&longitude=78.18&hourly=rain,showers&timezone=Asia/Kolkata&forecast_days=1"
            response = requests.get(url)
            data = response.json()
            
            hourly = data['hourly']
            timestamps = hourly['time']
            rain = [r + s for r, s in zip(hourly['rain'], hourly['showers'])]
            
            for i, t in enumerate(timestamps):
                dt = datetime.fromisoformat(t)
                if dt > now - timedelta(hours=1):
                    est_discharge = 5000 + (rain[i] * 1500)
                    forecast_data.append({
                        "time": dt.strftime("%H:%M"),
                        "rain": rain[i],
                        "discharge": round(est_discharge, 0),
                        "risk": 2 if est_discharge > 80000 else (1 if est_discharge > 30000 else 0)
                    })
                    if len(forecast_data) >= 12: break

        return jsonify(forecast_data)
        
    except Exception as e:
        print(f"Forecast Error: {e}")
        return jsonify([])


@app.route('/check-location', methods=['POST'])
def check_location():
    data = request.json
    lat = data.get('lat')
    lon = data.get('lon')
    
    elevation, source = get_elevation_from_mosaic(lat, lon)
    
    if elevation is None:
         return jsonify({'found': False, 'source': source})
    
    return jsonify({
        'found': True,
        'elevation': round(elevation, 3),
        'source': source
    })

if __name__ == '__main__':
    app.run(port=5000, debug=True)